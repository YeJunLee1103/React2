# 202030227 이예준

- [3주차](#0911-수업-내용)
- [5주차](#1002-수업-내용)
- [9주차](#1030-수업-내용)
- [10주차](#1106-수업-내용)
- [11주차](#1113-수업-내용)
- [12주차](#1120-수업-내용)

## 0911 수업 내용

---

렌더링(Rendering)

- 파일로 이뤄진 자료들을 완성된 웹페이지 화면에 그려주는데 그 과정을 돕는 것이 바로 렌더링(Rendering) 엔진

렌더링 전략

- Static Site Generation (SSG)
- Server-Side Rendering (SSR)
- Incremental Static Regeneraion (ISR)
- Clien Side Rendering (CSR)

### SSR

- 생소할 수도 있지만 웹 페이지를 제공하는 가장 흔한 방법
- APM을 이용하는 일반적인 웹 페이지 생성
- 여기에 자바스크립트 코드가 적재되면 동적으로 페이지 내용을 렌더링
- Next.js도 이와 같이 동적으로 페이지를 렌더링
- 스크립트 코드를 넣어서 동적으로 처리하게 되면 하이드레이션이라고 함
- 하이드레이션 덕분에 싱글 페이지 애플리케이션(SPA)처럼 작동

SSR의 장점

- 더 안전한 웹 애플리케이션 : 중요한 데이터를 클라이언트에 노출할 필요가 없음
- 더 뛰어난 웹 사이트 호환성 : 클라이언트 환경이 자바스크립트를 사용하지 못하거나 오래된 브라우저를 사용하더라도 서비스를 제공할 수 있음
- 더 뛰어난 SEO : 서버가 렌더링한 HTML을 받기 때문에 봇이나 웹 크롤러가 페이지를 렌더링할 필요가 없음

SSR이 최적의 렌더링 전략이 아닌 경우

- 클라이언트가 페이지를 요청할 때 마다 페이지를 다시 렌더링할 수 있는 서버 필요
- 다른 방식에 비해 더 많은 자원을 소모하고, 더 많은 부하를 보이며 더 많은 유지 보수 비용 필요
- 외부 API 또는 데이터 소스에 접근해야 한다면, 요청 필요
- 페이지 간의 오류가 CSR에 비해 느림

### CSR

- Ract 앱을 실행하면 렌더링 시작전에 빈 화면이 한동안 유지
- 이는 서버에서 스크립트와 스타일만 포함된 HTML을 전송
- 실제 렌더링은 클라이언트에서 이뤄짐
- 빌드 과정에서 1s와 Css파일을 HTML 페이지에 불러오도록 만들고 root div에 렌더링

CSR을 사용할 때 주요 이점

- 네이티브 앱처럼 느껴지는 웹 앱 : 전체 자바스크립트 번들을 다운로드 한다는 것은 랜더링할 모든 페이지가 이미 브라우저에 다운로드 되어 있다는 뜻
- 쉬운 페이지 전환
- 지연된 로딩과 성능 : 웹 앱은 최소로 필요한 HTML만 렌더링
- 서버 부하 감소 : 서버리스 환경에서 웹 앱을 제공

단점이 될 수도 있는 장점(CSR)

- 네트워크 속도가 느린 환경
- 검색 로봇에게도 그 내용을 빈 것으로 보임

### SSG

- SSG는 일부 또는 전체 페이지를 빌드 시점에 미리 렌더링

SSG의 장점

- 쉬운 확장 : CDN을 통해 파일을 제공, 캐시에 저장
- 뛰어난 성능 : 클라이언트나 서버가 무언가를 처리할 필요가 없음
- 더 안전한 API 요청 : 외부 API를 호출, 데이터베이스에 접근, 보호해야 할 데이터에 접근
- 프런트엔드 애플리케이션을 만들고 싶을 때 가장 좋은 방법
- 다음 배포 전까지 내용이 변하지 않음
- 이런 문제 때문에 나온 방법이 증분 정적 재생성(ISR)
- SSG와 ISR을 함께 사용하여 문제를 해결
- API 호출에 수 초가 소요
- 데이터를 불러 오기 위한 REST API 호출에 수 초가 소요
- 데이터가 자주 변하지 않으면 SSG와 ISR을 사용해서 데이터를 10분 동안 캐싱 할 수 있음

## 1030 수업 내용

#### 데이터 불러오기

- next 클라이언트와 서버 모두에서 데이터를 불러 올 수 있다
- 서버는 다음 두 가지 상황에서 데이터를 불러올 수 있다

1. 정적 페이지를 만들 때 getStaticProps함수를 사용해서, 빌드 시점에 데이터를 불러올 수 있다
2. 서버가 페이지를 렌더링할 때 getServerSideProps를 통해, 실행 도중 데이터를 불러올 수 있다

- 데이터 베이스에서 데이터를 가져올 수도 있지만 안전하지 않기 때문에 권장하지 않습니다 데이터 베이스와 접근은 벡엔드에서 처리하는 것이 좋다
- Next는 프런트엔드만 담당하는 것이 좋다

#### 서버가 데이터 불러오기

- 서버에서는 두 가지 방법으로 HTTP 요청을 만들고 처리할 수 있다

1. Node의 내장 HTTP 라이브러리를 사용할 수 있다
2. HTTP 클라이언트 라이브러리를 사용할 수 없다

- Axios를 사용하는 이유는 클라이언트와 서버 모두에서 동일하게 사용할 수 있고 npm을 통한 다운로드가 일주일에 약 1,700만 회에 달할 정도로 많이 사용하기 때문이다

#### REST API - 개요

- REST란 자원을 이름으로 구분하여 그 자원의 상태를 통신을 통해 주고 받는 것을 의미한다

- CRUD란 데이터 처리의 기본적인 기능을 나타낸다

1. Create : 데이터 생성
2. Read : 데이터 조회
3. Update : 데이터 수정
4. Delete : 데이터 삭제

- REST API란 REST의 규칙을 적용한 API를 의미한다

#### REST API - 기본 설계 규칙

- URI는 동사보다는 명사를, 대문자보다는 소문자를 사용하여야 한다
- 주소의 마지막에 슬래시(/)를 포함하지 않는다
- 단어를 연결할 때는 하이폰(-)을 사용한다
- 파일확장자는 URI에 포함하지 않는다
- URI에 메소드를 포함하지 않는다

#### JSON SERVER

- 벡엔드가 개발되기 전이나 외부 API가 결정되지 않았다면 local에 JSON SERVER를 구축하고 프런트엔드 개발을 하기에 적합한 node 패키지다

- 다음 명령으로 json-server를 설치하여 준다

- 설치가 잘 되었는지 version을 확인해 본다

#### Axios 설치

#### Axios 사용하기


## 1106 수업 내용

### CSS와 내장 스타일링 메서드

#### Styled JSX

- 리액트로 프로젝트를 개발할 때 사용되므로 공식적인 자바스크립트 문법은 아니다
- 브라우저에서 실행하기 전에 바벨을 사용하여 일반 자바스크립트 형태의 코드로 변환된다
- JSX는 하나의 파일에 자바스크립트와 HTML을 동시에 작성할 수 있어 편리하다

#### CSS Module

- CSS-in-JS의 단점을 회피하기 위한 좋은 방법은 CSS Module 이다

## 1113 수업 내용

### UI 라이브러리

- UI 라이브러리, 프레임워크, 유틸리티 기능이 필수는 아닙니다
- 다만 생산성 향상 및 UI의 일관성을 유지하는데 많은 도움을 받을 수 있습니다
- 이번 장에서는 다음 3가지의 프레임워크에 관해 간단히 알아 봅니다

### Chakra UI

- 오픈소스 컴포넌트 라이브러리로, 모듈화 되어 있고 접근성이 뛰어나며 보기 좋은 UI를 만들 수 있다
- 버튼, 모달, 입력 등 다양한 내장 컴포넌트를 제공한다
- dark mode 및 light mode를 모두 지원합니다
- Chakra UI의 useColorMode 훅을 사용해서 현재 사용하는 컬러 모드를 확인할 수 있습니다


### Tailwind CSS

- 다른 프레임워크와는 다르게 CSS 규칙만을 제공합니다
- 자바스크립트 모듈이나 리액트 컴포넌트를 제공하지 않기 때문에 필요한 경우 직접 만들어서 사용해야 합니다
- 변수값을 조정하여 개성있는 디자인을 만들 수 있습니다
- dark, light mode를 쉽게 적용할 수 있습니다
- 빌드 시점에 사용하지 않는 클래스를 제거 되기 때문에 높은 수준의 최적화를 지원합니다

### Headless UI
- Tailwind CSS를 만든 Tailwind Labs 팀의 무료 오픈소스 프로젝트입니다
- Tailwind CSS는 웹 컴포넌트 안에서 사용할 수 있는 CSS클래스만 제공합니다
- 따라서 모달이나 버튼 등 동적인 컴포넌트를 만들려면 직접 자바스크립트 코드를 작성해야 한다
- 이점을 보완하기 위해 Headless UI가 탄생했습니다

### Project 생성
- Tailwind 사용을 위해 프로젝트를 다시 생성합니다
- 프로젝트를 다시 생성하지 않고 설정할 수도 있지만 과정이 다소 복잡합니다
- 프로젝트는 Next.js 14로 합니다
- 프로젝트 이름은 자유로 하고, 나머지 모두 yes로 합니다

## 1120 수업 내용

### Props 흐름의 이해

- Next.js의 데이터 흐름은 단방향으로 이루어집니다
- parents에서 child component의 방향으로 props의 흐름이 이루어집니다
- Props Drilling은 여러 개의 component를 지나 props가 전달 되면서 발생하는 문제입니다
- Props Drilling은 다음과 같은 문제를 발생 시킬 수 있습니다
- 중간에 위치한 component에 불필요한 props를 전달해야 하는 문제
- 티켓 component까지 porps가 전달되지 않을 경우 원인 규명의 어려움
- 필요 이상으로 코드가 복잡해지는 문제

### Context API

- 옆에서 작성한 코드 상단에 use client 지시문이 있습니다
- Next.js에서 'use client'를 사용하는 이유는 서버 컴포넌트와 클라이언트 컴포넌트를 구분하기 위해서 입니다

### Context API vs Redux

- [Context API]
- React에서 기본으로 제공하는  상태 관리 도구로 외부 라이브러리 설치 없이 사용 가능합니다
- Context API는 주로 전역 상태를 관리하는 데 사용됩니다

- 장점
- 간단하고 가볍다
- 적은 설정이 필요하다
- 컴포넌트 트리의 깊이 제한이 없다

- 단점
- 복잡한 상태 관리에 한계가 있다
- 성능 문제가 있다
- 디버깅 도구가 부족하다

- [Redux]

- Redux는 전역 상태를 관리하기 위한 독립적인 state 관리 라이브러리입니다
- 상태의 변경을 예측 가능하게 하고, 전역 state 관리를 더 구조적으로 지원합니다
- store, reducer, action 등의 개념을 사용해 state와 dispatch를 관리합니다

- 장점
- 명확한 상태 관리 구조 : 액션과 reducer를 통해 state dispatch 과정을 예측 가능하게 만들고, 코드의 가독성을 높입니다
- 미들웨어 지원 : redux-thunk, redux-sage와 같은 미들웨어를 사용해 비동기 로직을 설계 처리할 수 있습니다
- 디버깅 도구 : Redux, DevTools를 통해 상태 변화 및 디버깅이 용이합니다
- 모든 프레임워크와 호환 : React뿐만 아니라 다른 JavaScript 프레임워크와도 함게 사용할 수 있습니다